{"ts":1358327336620,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * @fileoverview\n * \n * ECMAScript <a href=\"http://www.carto.net/papers/svg/resources/helper_functions.html\">helper functions</a>, main purpose is to serve in SVG mapping or other SVG based web applications\n *\n * This ECMA script library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library (http://www.carto.net/papers/svg/resources/lesser_gpl.txt); if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Please report bugs and send improvements to neumann@karto.baug.ethz.ch\n * If you use these scripts, please link to the original (http://www.carto.net/papers/svg/resources/helper_functions.html)\n * somewhere in the source-code-comment or the \"about\" of your project and give credits, thanks!\n * \n * See <a href=\"js_docs_out/overview-summary-helper_functions.js.html\">documentation</a>. \n * \n * @author Andreas Neumann a.neumann@carto.net\n * @copyright LGPL 2.1 <a href=\"http://www.gnu.org/copyleft/lesser.txt\">Gnu LGPL 2.1</a>\n * @credits Bruce Rindahl, numerous people on svgdevelopers@yahoogroups.com\n */\n\n//global variables necessary to create elements in these namespaces, do not delete them!!!!\n\n/**\n * This variable is a shortcut to the full URL of the SVG namespace\n * @final\n * @type String\n */\nvar svgNS = \"http://www.w3.org/2000/svg\";\n\n/**\n * This variable is a shortcut to the full URL of the XLink namespace\n * @final\n * @type String\n */\nvar xlinkNS = \"http://www.w3.org/1999/xlink\";\n\n/**\n * This variable is a shortcut to the full URL of the attrib namespace\n * @final\n * @type String\n */\nvar cartoNS = \"http://www.carto.net/attrib\";\n\n/**\n * This variable is a alias to the full URL of the attrib namespace\n * @final\n * @type String\n */\nvar attribNS = \"http://www.carto.net/attrib\";\n\n/**\n * This variable is a alias to the full URL of the Batik extension namespace\n * @final\n * @type String\n */\nvar batikNS = \"http://xml.apache.org/batik/ext\";\n\n/**\n * Returns the polar direction from a given vector\n * @param {Number} xdiff\tthe x-part of the vector\n * @param {Number} ydiff\tthe y-part of the vector\n * @return direction\t\tthe direction in radians\n * @type Number\n * @version 1.0 (2007-04-30)\n * @see #toPolarDist\n * @see #toRectX\n * @see #toRectY\n */\nfunction toPolarDir(xdiff,ydiff) {\n   var direction = (Math.atan2(ydiff,xdiff));\n   return(direction);\n}\n\n/**\n * Returns the polar distance from a given vector\n * @param {Number} xdiff\tthe x-part of the vector\n * @param {Number} ydiff\tthe y-part of the vector\n * @return distance\t\t\tthe distance\n * @type Number\n * @version 1.0 (2007-04-30)\n * @see #toPolarDir\n * @see #toRectX\n * @see #toRectY\n */\nfunction toPolarDist(xdiff,ydiff) {\n   var distance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n   return(distance);\n}\n\n/**\n * Returns the x-part of a vector from a given direction and distance\n * @param {Number} direction\tthe direction (in radians)\n * @param {Number} distance\t\tthe distance\n * @return x\t\t\t\t\tthe x-part of the vector\n * @type Number\n * @version 1.0 (2007-04-30)\n * @see #toPolarDist\n * @see #toPolarDir\n * @see #toRectY\n */\nfunction toRectX(direction,distance) {\n   var x = distance * Math.cos(direction);\n   return(x);\n}\n\n/**\n * Returns the y-part of the vector from a given direction and distance\n * @param {Number} direction\tthe direction (in radians)\n * @param {Number} distance\t\tthe distance\n * @return y\t\t\t\t\tthe y-part of the vector\n * @type Number\n * @version 1.0 (2007-04-30)\n * @see #toPolarDist\n * @see #toPolarDir\n * @see #toRectX\n */\nfunction toRectY(direction,distance) {\n   y = distance * Math.sin(direction);\n   return(y);\n}\n\n/**\n * Converts degrees to radians\n * @param {Number} deg\tthe degree value\n * @return rad\t\t\tthe radians value\n * @type Number\n * @version 1.0 (2007-04-30)\n * @see #RadToDeg\n */\nfunction DegToRad(deg) {\n     return (deg / 180.0 * Math.PI);\n}\n\n/**\n * Converts radians to degrees\n * @param {Number} rad\tthe radians value\n * @return deg\t\t\tthe degree value\n * @type Number\n * @version 1.0 (2007-04-30)\n * @see #DegToRad\n */\nfunction RadToDeg(rad) {\n     return (rad / Math.PI * 180.0);\n}\n\n/**\n * Converts decimal degrees to degrees, minutes, seconds\n * @param {Number} dd\tthe decimal degree value\n * @return degrees\t\tthe degree values in the following notation: {deg:degrees,min:minutes,sec:seconds}\n * @type literal\n * @version 1.0 (2007-04-30)\n * @see #dms2dd\n */\nfunction dd2dms(dd) {\n        var minutes = (Math.abs(dd) - Math.floor(Math.abs(dd))) * 60;\n        var seconds = (minutes - Math.floor(minutes)) * 60;\n        var minutes = Math.floor(minutes);\n        if (dd >= 0) {\n            var degrees = Math.floor(dd);\n        }\n        else {\n            var degrees = Math.ceil(dd);       \n        }\n        return {deg:degrees,min:minutes,sec:seconds};\n}\n\n/**\n * Converts degrees, minutes and seconds to decimal degrees\n * @param {Number} deg\tthe degree value\n * @param {Number} min\tthe minute value\n * @param {Number} sec\tthe second value\n * @return deg\t\t\tthe decimal degree values\n * @type Number\n * @version 1.0 (2007-04-30)\n * @see #dd2dms\n */\nfunction dms2dd(deg,min,sec) {\n\tif (deg < 0) {\n\t\treturn deg - (min / 60) - (sec / 3600);\n\t}\n\telse {\n\t\treturn deg + (min / 60) + (sec / 3600);\n\t}\n}\n\n/**\n * log function, missing in the standard Math object\n * @param {Number} x\tthe value where the log function should be applied to\n * @param {Number} b\tthe base value for the log function\n * @return logResult\tthe result of the log function\n * @type Number\n * @version 1.0 (2007-04-30)\n */\nfunction log(x,b) {\n\tif(b==null) b=Math.E;\n\treturn Math.log(x)/Math.log(b);\n}\n\n/**\n * interpolates a value (e.g. elevation) bilinearly based on the position within a cell with 4 corner values\n * @param {Number} za\t\tthe value at the upper left corner of the cell\n * @param {Number} zb\t\tthe value at the upper right corner of the cell\n * @param {Number} zc\t\tthe value at the lower right corner of the cell\n * @param {Number} zd\t\tthe value at the lower left corner of the cell\n * @param {Number} xpos\t\tthe x position of the point where a new value should be interpolated\n * @param {Number} ypos\t\tthe y position of the point where a new value should be interpolated\n * @param {Number} ax\t\tthe x position of the lower left corner of the cell\n * @param {Number} ay\t\tthe y position of the lower left corner of the cell\n * @param {Number} cellsize\tthe size of the cell\n * @return interpol_value\tthe result of the bilinear interpolation function\n * @type Number\n * @version 1.0 (2007-04-30)\n */\nfunction intBilinear(za,zb,zc,zd,xpos,ypos,ax,ay,cellsize) { //bilinear interpolation function\n\tvar e = (xpos - ax) / cellsize;\n\tvar f = (ypos - ay) / cellsize;\n\n\t//calculation of weights\n\tvar wa = (1 - e) * (1 - f);\n\tvar wb = e * (1 - f);\n\tvar wc = e * f;\n\tvar wd = f * (1 - e);\n\n\tvar interpol_value = wa * zc + wb * zd + wc * za + wd * zb;\n\treturn interpol_value;\t\n}\n\n/**\n * tests if a given point is left or right of a given line\n * @param {Number} pointx\t\tthe x position of the given point\n * @param {Number} pointy\t\tthe y position of the given point\n * @param {Number} linex1\t\tthe x position of line's start point\n * @param {Number} liney1\t\tthe y position of line's start point\n * @param {Number} linex2\t\tthe x position of line's end point\n * @param {Number} liney2\t\tthe y position of line's end point\n * @return leftof\t\t\t\tthe result of the leftOfTest, 1 means leftOf, 0 means rightOf\n * @type Number (integer, 0|1)\n * @version 1.0 (2007-04-30)\n */\nfunction leftOfTest(pointx,pointy,linex1,liney1,linex2,liney2) {\n\tvar result = (liney1 - pointy) * (linex2 - linex1) - (linex1 - pointx) * (liney2 - liney1);\n\tif (result < 0) {\n\t\tvar leftof = 1; //case left of\n\t}\n\telse {\n\t\tvar leftof = 0; //case left of\t\n\t}\n\treturn leftof;\n}\n\n/**\n * calculates the distance between a given point and a given line\n * @param {Number} pointx\t\tthe x position of the given point\n * @param {Number} pointy\t\tthe y position of the given point\n * @param {Number} linex1\t\tthe x position of line's start point\n * @param {Number} liney1\t\tthe y position of line's start point\n * @param {Number} linex2\t\tthe x position of line's end point\n * @param {Number} liney2\t\tthe y position of line's end point\n * @return distance\t\t\t\tthe result of the leftOfTest, 1 means leftOf, 0 means rightOf\n * @type Number\n * @version 1.0 (2007-04-30)\n */\nfunction distFromLine(xpoint,ypoint,linex1,liney1,linex2,liney2) {\n\tvar dx = linex2 - linex1;\n\tvar dy = liney2 - liney1;\n\tvar distance = (dy * (xpoint - linex1) - dx * (ypoint - liney1)) / Math.sqrt(Math.pow(dx,2) + Math.pow(dy,2));\n\treturn distance;\n}\n\n/**\n * calculates the angle between two vectors (lines)\n * @param {Number} ax\t\tthe x part of vector a\n * @param {Number} ay\t\tthe y part of vector a\n * @param {Number} bx\t\tthe x part of vector b\n * @param {Number} by\t\tthe y part of vector b\n * @return angle\t\t\tthe angle in radians\n * @type Number\n * @version 1.0 (2007-04-30)\n * @credits <a href=\"http://www.mathe-online.at/mathint/vect2/i.html#Winkel\">Mathe Online (Winkel)</a>\n */\nfunction angleBetwTwoLines(ax,ay,bx,by) {\n\tvar angle = Math.acos((ax * bx + ay * by) / (Math.sqrt(Math.pow(ax,2) + Math.pow(ay,2)) * Math.sqrt(Math.pow(bx,2) + Math.pow(by,2))));\n\treturn angle;\n}\n\n/**\n * calculates the bisector vector for two given vectors\n * @param {Number} ax\t\tthe x part of vector a\n * @param {Number} ay\t\tthe y part of vector a\n * @param {Number} bx\t\tthe x part of vector b\n * @param {Number} by\t\tthe y part of vector b\n * @return c\t\t\t\tthe resulting vector as an Array, c[0] is the x part of the vector, c[1] is the y part\n * @type Array\n * @version 1.0 (2007-04-30)\n * @credits <a href=\"http://www.mathe-online.at/mathint/vect1/i.html#Winkelsymmetrale\">Mathe Online (Winkelsymmetrale)</a>\n * see #calcBisectorAngle\n *  */\nfunction calcBisectorVector(ax,ay,bx,by) {\n\tvar betraga = Math.sqrt(Math.pow(ax,2) + Math.pow(ay,2));\n\tvar betragb = Math.sqrt(Math.pow(bx,2) + Math.pow(by,2));\n\tvar c = new Array();\n\tc[0] = ax / betraga + bx / betragb;\n\tc[1] = ay / betraga + by / betragb;\n\treturn c;\n}\n\n/**\n * calculates the bisector angle for two given vectors\n * @param {Number} ax\t\tthe x part of vector a\n * @param {Number} ay\t\tthe y part of vector a\n * @param {Number} bx\t\tthe x part of vector b\n * @param {Number} by\t\tthe y part of vector b\n * @return angle\t\t\tthe bisector angle in radians\n * @type Number\n * @version 1.0 (2007-04-30)\n * @credits <a href=\"http://www.mathe-online.at/mathint/vect1/i.html#Winkelsymmetrale\">Mathe Online (Winkelsymmetrale)</a>\n * see #calcBisectorVector\n * */\nfunction calcBisectorAngle(ax,ay,bx,by) {\n\tvar betraga = Math.sqrt(Math.pow(ax,2) + Math.pow(ay,2));\n\tvar betragb = Math.sqrt(Math.pow(bx,2) + Math.pow(by,2));\n\tvar c1 = ax / betraga + bx / betragb;\n\tvar c2 = ay / betraga + by / betragb;\n\tvar angle = toPolarDir(c1,c2);\n\treturn angle;\n}\n\n/**\n * calculates the intersection point of two given lines\n * @param {Number} line1x1\tthe x the start point of line 1\n * @param {Number} line1y1\tthe y the start point of line 1\n * @param {Number} line1x2\tthe x the end point of line 1\n * @param {Number} line1y2\tthe y the end point of line 1\n * @return interSectPoint\tthe intersection point, interSectPoint.x contains x-part, interSectPoint.y the y-part of the resulting coordinate\n * @type Object\n * @version 1.0 (2007-04-30)\n * @credits <a href=\"http://astronomy.swin.edu.au/~pbourke/geometry/lineline2d/\">P. Bourke</a>\n */\nfunction intersect2lines(line1x1,line1y1,line1x2,line1y2,line2x1,line2y1,line2x2,line2y2) {\n\tvar interSectPoint = new Object();\n\tvar denominator = (line2y2 - line2y1)*(line1x2 - line1x1) - (line2x2 - line2x1)*(line1y2 - line1y1);\n\tif (denominator == 0) {\n\t\talert(\"lines are parallel\");\n\t}\n\telse {\n\t\tvar ua = ((line2x2 - line2x1)*(line1y1 - line2y1) - (line2y2 - line2y1)*(line1x1 - line2x1)) / denominator;\n\t\tvar ub = ((line1x2 - line1x1)*(line1y1 - line2y1) - (line1y2 - line1y1)*(line1x1 - line2x1)) / denominator;\n\t}\n\tinterSectPoint[\"x\"] = line1x1 + ua * (line1x2 - line1x1);\n\tinterSectPoint[\"y\"] = line1y1 + ua * (line1y2 - line1y1);\n\treturn interSectPoint;\n}\n\n/**\n * reformats a given number to a string by adding separators at every third digit\n * @param {String|Number} inputNumber\tthe input number, can be of type number or string\n * @param {String} separator\t\t\tthe separator, e.g. ' or ,\n * @return newString\t\t\t\t\tthe intersection point, interSectPoint.x contains x-part, interSectPoint.y the y-part of the resulting coordinate\n * @type String\n * @version 1.0 (2007-04-30)\n */\nfunction formatNumberString(inputNumber,separator) {\n\t//check if of type string, if number, convert it to string\n\tif (typeof(inputNumber) == \"Number\") {\n\t\tvar myTempString = inputNumber.toString();\n\t}\n\telse {\n\t\tvar myTempString = inputNumber;\n\t}\n\tvar newString=\"\";\n\t//if it contains a comma, it will be split\n\tvar splitResults = myTempString.split(\".\");\n\tvar myCounter = splitResults[0].length;\n\tif (myCounter > 3) {\n\t\twhile(myCounter > 0) {\n\t\t\tif (myCounter > 3) {\n\t\t\t\tnewString = separator + splitResults[0].substr(myCounter - 3,3) + newString;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnewString = splitResults[0].substr(0,myCounter) + newString;\n\t\t\t}\n\t\t\tmyCounter -= 3;\n\t\t}\n\t}\n\telse {\n\t\tnewString = splitResults[0];\n\t}\n\t//concatenate if it contains a comma\n\tif (splitResults[1]) {\n\t\tnewString = newString + \".\" + splitResults[1];\n\t}\n\treturn newString;\n}\n\n/**\n * writes a status text message out to a SVG text element's first child\n * @param {String} statusText\tthe text message to be displayed\n * @version 1.0 (2007-04-30)\n */\n function statusChange(statusText) {\n\tdocument.getElementById(\"statusText\").firstChild.nodeValue = \"Statusbar: \" + statusText;\n}\n\n/**\n * scales an SVG element, requires that the element has an x and y attribute (e.g. circle, ellipse, use element, etc.)\n * @param {dom::Event} evt\t\tthe evt object that triggered the scaling\n * @param {Number} factor\tthe scaling factor\n * @version 1.0 (2007-04-30)\n */\nfunction scaleObject(evt,factor) {\n\t//reference to the currently selected object\n\tvar element = evt.currentTarget;\n\tvar myX = element.getAttributeNS(null,\"x\");\n\tvar myY = element.getAttributeNS(null,\"y\");\n\tvar newtransform = \"scale(\" + factor + \") translate(\" + (myX * 1 / factor - myX) + \" \" + (myY * 1 / factor - myY) +\")\";\n\telement.setAttributeNS(null,'transform', newtransform);\n}\n\n/**\n * returns the transformation matrix (ctm) for the given node up to the root element\n * the basic use case is to provide a wrapper function for the missing SVGLocatable.getTransformToElement method (missing in ASV3)\n * @param {svg::SVGTransformable} node\t\tthe node reference for the SVGElement the ctm is queried\n * @return CTM\t\t\t\t\t\t\t\tthe current transformation matrix from the given node to the root element\n * @type svg::SVGMatrix\n * @version 1.0 (2007-05-01)\n * @credits <a href=\"http://www.kevlindev.com/tutorials/basics/transformations/toUserSpace/index.htm\">Kevin Lindsey (toUserSpace)</a>\n * @see #getTransformToElement\n */\nfunction getTransformToRootElement(node) {\n \ttry {\n\t\t//this part is for fully conformant players (like Opera, Batik, Firefox, Safari ...)\n\t\tvar CTM = node.getTransformToElement(document.documentElement);\n\t}\n\tcatch (ex) {\n\t\t//this part is for ASV3 or other non-conformant players\n\t\t// Initialize our CTM the node's Current Transformation Matrix\n\t\tvar CTM = node.getCTM();\n\t\t// Work our way through the ancestor nodes stopping at the SVG Document\n\t\twhile ( ( node = node.parentNode ) != document ) {\n\t\t\t// Multiply the new CTM to the one with what we have accumulated so far\n\t\t\tCTM = node.getCTM().multiply(CTM);\n\t\t}\n\t}\n\treturn CTM;\n}\n\n/**\n * returns the transformation matrix (ctm) for the given dom::Node up to a different dom::Node\n * the basic use case is to provide a wrapper function for the missing SVGLocatable.getTransformToElement method (missing in ASV3)\n * @param {svg::SVGTransformable} node\t\t\tthe node reference for the element the where the ctm should be calculated from\n * @param {svg::SVGTransformable} targetNode\tthe target node reference for the element the ctm should be calculated to\n * @return CTM\t\t\t\t\t\t\t\t\tthe current transformation matrix from the given node to the target element\n * @type svg::SVGMatrix\n * @version 1.0 (2007-05-01)\n * @credits <a href=\"http://www.kevlindev.com/tutorials/basics/transformations/toUserSpace/index.htm\">Kevin Lindsey (toUserSpace)</a>\n * @see #getTransformToRootElement\n */\nfunction getTransformToElement(node,targetNode) {\n    try {\n        //this part is for fully conformant players\n        var CTM = node.getTransformToElement(targetNode);\n    }\n    catch (ex) {\n  \t\t//this part is for ASV3 or other non-conformant players\n\t\t// Initialize our CTM the node's Current Transformation Matrix\n\t\tvar CTM = node.getCTM();\n\t\t// Work our way through the ancestor nodes stopping at the SVG Document\n\t\twhile ( ( node = node.parentNode ) != targetNode ) {\n\t\t\t// Multiply the new CTM to the one with what we have accumulated so far\n\t\t\tCTM = node.getCTM().multiply(CTM);\n\t\t}\n    }\n    return CTM;\n}\n\n/**\n * converts HSV to RGB values\n * @param {Number} hue\t\tthe hue value (between 0 and 360)\n * @param {Number} sat\t\tthe saturation value (between 0 and 1)\n * @param {Number} val\t\tthe value value (between 0 and 1)\n * @return rgbArr\t\t\tthe rgb values (associative array or object, the keys are: red,green,blue), all values are scaled between 0 and 255\n * @type Object\n * @version 1.0 (2007-05-01)\n * @see #rgb2hsv\n */\nfunction hsv2rgb(hue,sat,val) {\n\tvar rgbArr = new Object();\n\tif ( sat == 0) {\n\t\trgbArr[\"red\"] = Math.round(val * 255);\n\t\trgbArr[\"green\"] = Math.round(val * 255);\n\t\trgbArr[\"blue\"] = Math.round(val * 255);\n\t}\n\telse {\n\t\tvar h = hue / 60;\n\t\tvar i = Math.floor(h);\n\t\tvar f = h - i;\n\t\tif (i % 2 == 0) {\n\t\t\tf = 1 - f;\n\t\t}\n\t\tvar m = val * (1 - sat); \n\t\tvar n = val * (1 - sat * f);\n\t\tswitch(i) {\n\t\t\tcase 0:\n\t\t\t\trgbArr[\"red\"] = val;\n\t\t\t\trgbArr[\"green\"] = n;\n\t\t\t\trgbArr[\"blue\"] = m;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trgbArr[\"red\"] = n;\n\t\t\t\trgbArr[\"green\"] = val;\n\t\t\t\trgbArr[\"blue\"] = m;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\trgbArr[\"red\"] = m;\n\t\t\t\trgbArr[\"green\"] = val;\n\t\t\t\trgbArr[\"blue\"] = n;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\trgbArr[\"red\"] = m;\n\t\t\t\trgbArr[\"green\"] = n;\n\t\t\t\trgbArr[\"blue\"] = val;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\trgbArr[\"red\"] = n;\n\t\t\t\trgbArr[\"green\"] = m;\n\t\t\t\trgbArr[\"blue\"] = val;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\trgbArr[\"red\"] = val;\n\t\t\t\trgbArr[\"green\"] = m;\n\t\t\t\trgbArr[\"blue\"] = n;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\trgbArr[\"red\"] = val;\n\t\t\t\trgbArr[\"green\"] = n;\n\t\t\t\trgbArr[\"blue\"] = m;\n\t\t\t\tbreak;\n\t\t}\n\t\trgbArr[\"red\"] = Math.round(rgbArr[\"red\"] * 255);\n\t\trgbArr[\"green\"] = Math.round(rgbArr[\"green\"] * 255);\n\t\trgbArr[\"blue\"] = Math.round(rgbArr[\"blue\"] * 255);\n\t}\n\treturn rgbArr;\n}\n\n/**\n * converts RGB to HSV values\n * @param {Number} red\t\tthe hue value (between 0 and 255)\n * @param {Number} green\tthe saturation value (between 0 and 255)\n * @param {Number} blue\t\tthe value value (between 0 and 255)\n * @return hsvArr\t\t\tthe hsv values (associative array or object, the keys are: hue (0-360),sat (0-1),val (0-1))\n * @type Object\n * @version 1.0 (2007-05-01)\n * @see #hsv2rgb\n */\nfunction rgb2hsv(red,green,blue) {\n\tvar hsvArr = new Object();\n\tred = red / 255;\n\tgreen = green / 255;\n\tblue = blue / 255;\n\tmyMax = Math.max(red, Math.max(green,blue));\n\tmyMin = Math.min(red, Math.min(green,blue));\n\tv = myMax;\n\tif (myMax > 0) {\n\t\ts = (myMax - myMin) / myMax;\n\t}\n\telse {\n\t\ts = 0;\n\t}\n\tif (s > 0) {\n\t\tmyDiff = myMax - myMin;\n\t\trc = (myMax - red) / myDiff;\n\t\tgc = (myMax - green) / myDiff;\n\t\tbc = (myMax - blue) / myDiff;\n\t\tif (red == myMax) {\n\t\t\th = (bc - gc) / 6;\n\t\t}\n\t\tif (green == myMax) {\n\t\t\th = (2 + rc - bc) / 6;\n\t\t}\n\t\tif (blue == myMax) {\n\t\t\th = (4 + gc - rc) / 6;\n\t\t}\n\t}\n\telse {\n\t\th = 0;\n\t}\n\tif (h < 0) {\n\t\th += 1;\n\t}\n\thsvArr[\"hue\"] = Math.round(h * 360);\n\thsvArr[\"sat\"] = s;\n\thsvArr[\"val\"] = v;\n\treturn hsvArr;\n}\n\n/**\n * populates an array such that it can be addressed by both a key or an index nr,\n * note that both Arrays need to be of the same length\n * @param {Array} arrayKeys\t\tthe array containing the keys\n * @param {Array} arrayValues\tthe array containing the values\n * @return returnArray\t\t\tthe resulting array containing both associative values and also a regular indexed array\n * @type Array\n * @version 1.0 (2007-05-01)\n */\nfunction arrayPopulate(arrayKeys,arrayValues) {\n\tvar returnArray = new Array();\n\tif (arrayKeys.length != arrayValues.length) {\n\t\talert(\"error: arrays do not have the same length!\");\n\t}\n\telse {\n\t\tfor (i=0;i<arrayKeys.length;i++) {\n\t\t\treturnArray[arrayKeys[i]] = arrayValues[i];\n\t\t}\n\t}\n\treturn returnArray;\n}\n\n/**\n * Wrapper object for network requests, uses getURL or XMLHttpRequest depending on availability\n * The callBackFunction receives a XML or text node representing the rootElement\n * of the fragment received or the return text, depending on the returnFormat. \n * See also the following <a href=\"http://www.carto.net/papers/svg/network_requests/\">documentation</a>.\n * @class this is a wrapper object to provide network request functionality (get|post)\n * @param {String} url\t\t\t\t\t\t\t\t\t\t\t\tthe URL/IRI of the network resource to be called\n * @param {Function|Object} callBackFunction\t\t\t\t\t\tthe callBack function or object that is called after the data was received, in case of an object, the method 'receiveData' is called; both the function and the object's 'receiveData' method get 2 return parameters: 'node.firstChild'|text (the root element of the XML or text resource), this.additionalParams (if defined) \n * @param {String} returnFormat\t\t\t\t\t\t\t\t\t\tthe return format, either 'xml' or 'json' (or text)\n * @param {String} method\t\t\t\t\t\t\t\t\t\t\tthe method of the network request, either 'get' or 'post'\n * @param {String|Undefined} postText\t\t\t\t\t\t\t\tthe String containing the post text (optional) or Undefined (if not a 'post' request)\n * @param {Object|Array|String|Number|Undefined} additionalParams\tadditional parameters that will be passed to the callBackFunction or object (optional) or Undefined\n * @return a new getData instance\n * @type getData\n * @constructor\n * @version 1.0 (2007-02-23)\n */\nfunction getData(url,callBackFunction,returnFormat,method,postText,additionalParams) {\n\tthis.url = url;\n\tthis.callBackFunction = callBackFunction;\n\tthis.returnFormat = returnFormat;\n\tthis.method = method;\n\tthis.additionalParams = additionalParams;\n\tif (method != \"get\" && method != \"post\") {\n\t\talert(\"Error in network request: parameter 'method' must be 'get' or 'post'\");\n\t}\n\tthis.postText = postText;\n\tthis.xmlRequest = null; //@private reference to the XMLHttpRequest object\n} \n\n/**\n * triggers the network request defined in the constructor\n */\ngetData.prototype.getData = function() {\n\t//call getURL() if available\n\tif (window.getURL) {\n\t\tif (this.method == \"get\") {\n\t\t\tgetURL(this.url,this);\n\t\t}\n\t\tif (this.method == \"post\") {\n\t\t\tpostURL(this.url,this.postText,this);\n\t\t}\n\t}\n\t//or call XMLHttpRequest() if available\n\telse if (window.XMLHttpRequest) {\n\t\tvar _this = this;\n\t\tthis.xmlRequest = new XMLHttpRequest();\n\t\tif (this.method == \"get\") {\n\t\t\tif (this.returnFormat == \"xml\") {\n\t\t\t\tthis.xmlRequest.overrideMimeType(\"text/xml\");\n\t\t\t}\n\t\t\tthis.xmlRequest.open(\"GET\",this.url,true);\n\t\t}\n\t\tif (this.method == \"post\") {\n\t\t\tthis.xmlRequest.open(\"POST\",this.url,true);\n\t\t}\n\t\tthis.xmlRequest.onreadystatechange = function() {_this.handleEvent()};\n\t\tif (this.method == \"get\") {\n\t\t\tthis.xmlRequest.send(null);\n\t\t}\n\t\tif (this.method == \"post\") {\n\t\t\t//test if postText exists and is of type string\n\t\t\tvar reallyPost = true;\n\t\t\tif (!this.postText) {\n\t\t\t\treallyPost = false;\n\t\t\t\talert(\"Error in network post request: missing parameter 'postText'!\");\n\t\t\t}\n\t\t\tif (typeof(this.postText) != \"string\") {\n\t\t\t\treallyPost = false;\n\t\t\t\talert(\"Error in network post request: parameter 'postText' has to be of type 'string')\");\n\t\t\t}\n\t\t\tif (reallyPost) {\n\t\t\t\tthis.xmlRequest.send(this.postText);\n\t\t\t}\n\t\t}\n\t}\n\t//write an error message if neither method is available\n\telse {\n\t\talert(\"your browser/svg viewer neither supports window.getURL nor window.XMLHttpRequest!\");\n\t}\t\n}\n\n/**\n * this is the callback method for the getURL() or postURL() case\n * @private\n */\ngetData.prototype.operationComplete = function(data) {\n\t//check if data has a success property\n\tif (data.success) {\n\t\t//parse content of the XML format to the variable \"node\"\n\t\tif (this.returnFormat == \"xml\") {\n\t\t\t//convert the text information to an XML node and get the first child\n\t\t\tvar node = parseXML(data.content,document);\n\t\t\t//distinguish between a callback function and an object\n\t\t\tif (typeof(this.callBackFunction) == \"function\") {\n\t\t\t\tthis.callBackFunction(node.firstChild,this.additionalParams);\n\t\t\t}\n\t\t\tif (typeof(this.callBackFunction) == \"object\") {\n\t\t\t\tthis.callBackFunction.receiveData(node.firstChild,this.additionalParams);\n\t\t\t}\n\t\t}\n\t\tif (this.returnFormat == \"json\") {\n\t\t\tif (typeof(this.callBackFunction) == \"function\") {\n\t\t\t\tthis.callBackFunction(data.content,this.additionalParams);\n\t\t\t}\n\t\t\tif (typeof(this.callBackFunction) == \"object\") {\n\t\t\t\tthis.callBackFunction.receiveData(data.content,this.additionalParams);\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\telse {\n\t\talert(\"something went wrong with dynamic loading of geometry!\");\n\t}\n}\n\n/**\n * this is the callback method for the XMLHttpRequest case\n * @private\n */\ngetData.prototype.handleEvent = function() {\n\tif (this.xmlRequest.readyState == 4) {\n\t\tif (this.returnFormat == \"xml\") {\n\t\t\t//we need to import the XML node first\n\t\t\tvar importedNode = document.importNode(this.xmlRequest.responseXML.documentElement,true);\n\t\t\tif (typeof(this.callBackFunction) == \"function\") {\n\t\t\t\tthis.callBackFunction(importedNode,this.additionalParams);\n\t\t\t}\n\t\t\tif (typeof(this.callBackFunction) == \"object\") {\n\t\t\t\tthis.callBackFunction.receiveData(importedNode,this.additionalParams);\n\t\t\t}\t\t\t\n\t\t}\n\t\tif (this.returnFormat == \"json\") {\n\t\t\tif (typeof(this.callBackFunction) == \"function\") {\n\t\t\t\tthis.callBackFunction(this.xmlRequest.responseText,this.additionalParams);\n\t\t\t}\n\t\t\tif (typeof(this.callBackFunction) == \"object\") {\n\t\t\t\tthis.callBackFunction.receiveData(this.xmlRequest.responseText,this.additionalParams);\n\t\t\t}\t\t\t\n\t\t}\t\t\n\t}\t\n}\n\n/**\n * Serializes an XML node and returns a string representation. Wrapper function to hide implementation differences. \n * This can be used for debugging purposes or to post data to a server or network resource.\n * @param {dom::Node} node\t\tthe DOM node reference\n * @return textRepresentation\tthe String representation of the XML node\n * @type String\n * @version 1.0 (2007-05-01)\n * @see getData\n */\nfunction serializeNode(node) {\n  if (typeof XMLSerializer != 'undefined') {\n    return new XMLSerializer().serializeToString(node);\n  }\n  else if (typeof node.xml != 'undefined') {\n    return node.xml;\n  }\n  else if (typeof printNode != 'undefined') {\n    return printNode(node);\n  }\n  else if (typeof Packages != 'undefined') {\n    try {\n      var stringWriter = new java.io.StringWriter();\n      Packages.org.apache.batik.dom.util.DOMUtilities.writeNode(node,stringWriter);\n      return stringWriter.toString();\n    }\n    catch (e) {\n       alert(\"Sorry, your SVG viewer does not support the printNode/serialize function.\");\n       return '';\n    }\n  }\n  else {\n    alert(\"Sorry, your SVG viewer does not support the printNode/serialize function.\");\n    return '';\n  }\n}\n\n/**\n * Starts a SMIL animation element with the given id by triggering the '.beginElement()' method. \n * This is a convenience (shortcut) function. \n * @param {String} id\t\ta valid id of a valid SMIL animation element\n * @version 1.0 (2007-05-01)\n */\n//starts an animtion with the given id\n//this function is useful in combination with window.setTimeout()\nfunction startAnimation(id) {\n\t\tdocument.getElementById(id).beginElement();\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":28086}]],"length":28086}
